# 前言

在javascript发展初期就是为了实现简单的页面交互逻辑，代码管理的量较少。如今，随着CPU和浏览器的性能提升，web2.0的到来，Ajax得到广泛的引用，各种js前端框架层出不穷，js的代码亟需使用模块化去管理。

为什么需要模块化，模块化的优缺点以及规范是什么？



## 一、模块化的理解

### **1、什么是模块化**

- 将一个复杂的程序依据一定的规范封装成几个块（文件），并进行组合
- 块的内部数据与函数实现是私有的，只是向外部暴露一些接口方法与外部模块进行通信

### **2、模块化的进化史**

- 全局function模式：将不同的功能封装成不同的全局函数

  1）编码：将不同的功能封装成不同的全局函数

  2）缺点：容易污染全局命名空间，引起命名冲突和数据不安全，代码结构复杂

  ```js
  function name1(){
    //todo
  }
  function name1(){
    //todo
  }
  ```

- namesapce模式：简单对象的封装

  1）作用：封装到各自的对象环境中，减少了全局变量，解决了命名冲突

  2）问题：数据不安全（外部可以直接修改内部的数据），还没达到私有的状态

  ```js
  let myModule2 = {
      data: "halo name m2",
      foo() {
          console.log('halo name m2 foo',this.data)
      },
      bar() {
          console.log("halo name m2 bar",this.data)
      }
  }
  
  // 修改数据
  myModule1.data = 'change module1 data,hhahha'
  myModule1.foo()
  // halo name m1 foo change module1 data,hhahha
  
  ```

- IIFE模式：自执行匿名函数（闭包）

  1）作用：数据是私有的，外部只能通过暴露的方法去操作

  2）编码：将数据和函数封装到一个函数的内部，通过window来挂载，给外部调用

  3）缺点：虽可以通过入参函数来依赖外部，但是代码结构不明确

  ```js
  // 外部依赖的函数，可以是jq或其他js框架
  var data = function name(params) {
      return '233'
  };
  
  (function(window,data) {
  
      // 操作数据的函数
      function foo() {
          console.log(`foo()${data()}`)
      }
  
      // 暴露内部私有函数，通过window挂载到全局
      window.myModule = { foo,}
  })(window,data)
  ```

### **3、代码模块化的好处**

- 避免命名冲突（减少命名空间污染）
- 更好的分离，按需加载
- 更高的可复用性
- 高可维护性

### **4、引入多个script文件易出现的问题**

- 浏览器的请求事务过多

  我们需要依赖多个模块，一个模块就是一个文件，容易导致浏览器的请求进行的事务过多

- 依赖模糊

  多个依赖包的加载，无法明确知道他们的依赖关系，容易导致加载的先后顺序报错

- 难以维护

  请求事务过多，包与包的依赖模糊，多因素（网络请求慢，文件损坏）等问题能导致程序出现严重问题，难以排查。

  因此需要一个模块化的规范来解决这些问题。

## 二、模块化规范

### **1、CommonJs**

- CommonJs概述

  Node.js采用的是CommonJs来管理应用模块，每个文件就是一个模块，模块有私有的作用域，文件里面的命名数据，方法函数都是私有的。

  在服务端，模块加载是运行时同步加载的，在浏览器端，模块需要提前编译打包。

- CommonJS的特点

  1）代码都运行在模块作用域，不会污染全局作用域。

  2）CommonJs是采用缓存加载，第一次加载后，被存入缓存中，下次其他模块调用，直接在缓存获取，若让模块继续运行，需要清除缓存，重新加载，与ES6的引用加载不同（稍后在es6模块中讲述）。

  3）模块的加载顺序是有序的，按照其在代码中出现的顺序加载。

- CommonJs的基本语法

  1）暴露模块：`module.exports=xxx`or `exports.xxx = value`

  2）引入模块：`let JQ = require(jquery)`or `let myModule = require(./modules/mymodule.js)`

  ​	第三方模块直接引用名词，自定义模块需要引入模块的路径。

#### `CommonJs`暴露的模块是什么?

`CommonJs`规定，每个内部模块，`module`变量代表当前模块。`exports`属性是对外的接口，在加载某个属性，其实就是加载模块的`module.exports`属性。

##### 在本地Node.js，尝试运行CommonJs

```js
// module1.js
"use strict"
module.exports = {
    foo() {
        console.log('m1 foo()')
    }
}

// main.js
// CommonJS规范加载模块是同步的
let m1 = require("./module/module1")
m1.foo() //m1 foo()
```

若要在浏览器执行这些模块的代码，可以选择的方式:

1. CommonJs模块化的代码在浏览器执行，借助**Browserify**打包，生产的bundle.js文件引入到html中
2. Es6模块化的代码在浏览器执行，借助Babel，生产的bundle.js文件引入到html中



### **2、AMD**

- AMD概述

  Node.js采用的是CommonJs来管理应用模块，由于模块文件存储在本地的硬盘，所以加载起来速度比较快，因此可以用同步的方式。

  但是，在浏览器中，从服务加载文件需采用异步，因此使用AMD模式，比CommonJs模式更好。

- AMD基本语法

  1）暴露模块：

  ```js
  // 定义模块
  define(function () {
      let showMsg = xxx
      // 抛出模块
      return { showMsg }
  })
  
  // 定义依赖的模块
  define(['dataService'],function (dataService) {
      let name = 'tom'
      function showMsg() {
          alert(dataService.showMsg()+''+name)
      }
      return { showMsg }
  })
  ```

#### 未使用AMD规范

```js
// alerter.js
(function (window,dataService) {
    let name = 'tom'
    function showMsg() {
        alert(dataService.showMsg()+''+name)
    }
    window.alerter = { showMsg }
})(window,dataService)
```

```js
// dataService.js
(function (window) {
    let msg = 'www.baidu.com'
    function showMsg() {
        return msg.toUpperCase()
    }
    window.dataService = { showMsg }
})(window)
```

```js
// main.js
(function (alerter) {
    alerter.showMsg()
})(alerter)
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div>未使用AMD规范</div>
    <div>依赖的前置函数容易报错</div>
    <div>引用的顺序一定要正确</div>
</body>
<!-- <script src="./alerter.js"></script>
<script src="./dataService.js"></script>
<script src="./main.js"></script> -->
<!-- Uncaught ReferenceError: dataService is not defined -->
<!-- Uncaught TypeError: alerter.showMsg is not a function -->

<script src="./dataService.js"></script>
<script src="./alerter.js"></script>
<script src="./main.js"></script>
    <!-- alert: WWW.BAIDU.COMtom -->
</html>
```



#### 使用AMD规范，require.js

RequireJs是一个JS工具库，用于客户端的模块化管理，RequireJs遵守的是AMD规范。

基本思想：通过define方法定义为模块，用require方法实现模块加载。

**实现步骤：**

1. 构建目录结构

   ```
   |-js
     |-libs
       |-require.js
     |-modules
       |-alerter.js
       |-dataService.js
     |-main.js
   |-index.html
   ```

2. 在官方下载require.js文件，放到js/libs文件夹中待使用。

3. 在alerter.js和dataService.js中创建AMD规范的代码

   ```js
   // alerter.js
   define(['dataService'],function (dataService) {
       let name = 'tom'
       function showMsg() {
           alert(dataService.showMsg()+''+name)
       }
       return { showMsg }
   })
   ```

   ```js
   // dataService.js
   define(function () {
       let msg = 'www.baidu.com'
       function showMsg() {
           return msg.toUpperCase()
       }
       return { showMsg }
   })
   ```

4. main.js中引用模块代码

   ```js
   (function () {
       require.config({
           baseUrl: 'js/', // 基本路径
           paths: {
               // 映射，模块标识名，路径
               alerter: './modules/alerter',// 此处不能写alerter.js，会报错
               dataService: './modules/dataService'
           }
       })
       require(['alerter'],function (alerter) {
           alerter.showMsg()
       })
   })()
   ```

5. 在index.html中使用

   ```html
   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="UTF-8">
       <meta http-equiv="X-UA-Compatible" content="IE=edge">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   <body>
       <div>RequireJS是一个工具库，主要用于客户端的模块管理</div>
       <div>它的模块管理遵守AMD规范，RequireJS的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载</div>
       <script data-main="js/main" src="js/libs/require.js"></script>
   </body>
   </html>
   ```

**AMD总结：**

使用AMD规范，定义的模块方法非常清晰，不会污染全局环境，能够清晰的看出模块间的依赖。

异步加载的AMD规范，能提高浏览器的加载速度，根据需要按需动态加载模块。

### **3、CMD**

- CMD概述

  CMD规范专门用于浏览器，模块加载是异步的，模块使用时才会加载。

  CMD规范整合了CommonJs和AMD规范的特点。

  sea.js是使用了CMD规范的js框架。

- CMD基本语法

  1）暴露模块：

  ```js
  // 定义没有依赖的模块
  define(function () {
      exports.xxx = value
      module.exports = value
  })
  
  //定义有依赖的模块
  define(function(require, exports, module){
    //引入依赖模块(同步)
    var module2 = require('./module2')
    //引入依赖模块(异步)
      require.async('./module3', function (m3) {
      })
    //暴露模块
    exports.xxx = value
  })
  ```

#### 使用CMD规范，sea.js

**实现步骤：**

1. 构建目录结构

   ```
   |-js
     |-libs
       |-sea.js
     |-modules
       |-module1.js
       |-module2.js
       |-module3.js
       |-module4.js
       |-main.js
   |-index.html
   ```

2. 在官方下载sea.js文件，放到js/libs文件夹中待使用。

3. 创建CMD规范的代码

   ```js
   // module1.js
   define(function (require,exports,module) {
       var data ='www.baidu.com'
       function show() {
           console.log('m1 show()'+data)
       }
       // 抛出方法
       exports.show = show
   })
   ```

   ```js
   // module2.js
   define(function (require,exports,module) {
       module.exports = {
           msg: 'm2: i will back'
       }
   })
   
   // module3.js
   define(function (require,exports,module) {
       const API_KEY = 'm3 hahahaha'
       exports.API_KEY = API_KEY
   })
   
   // module4.js
   define(function (require,exports,module) {
       // 引入依赖模块（同步）
       var module2 = require("./module2")
       function show() {
           console.log('m4 show->>'+module2.msg)
       }
       exports.show = show
       // 抛出m4的方法
       // 以入依赖（异步）
       require.async('./module3',function (m3) {
           console.log('异步引入依赖模块'+m3.API_KEY)
       })
   })
   ```

4. main.js中引用模块代码

   ```js
   define(function (require,exports,module) {
      var m1 = require('./module1')
      var m4 = require('./module4')
      m1.show()
      m4.show()
   })
   ```

5. 在index.html中使用

   ```html
   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="UTF-8">
       <meta http-equiv="X-UA-Compatible" content="IE=edge">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   <body>
       <div>MD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。</div>
       <div>
           CMD规范整合了CommonJS和AMD规范的特点
       </div>
       
   </body>
   <script src="./js/lib/sea.js"></script>
   <script>
       seajs.use('./js/modules/main')
       // m1 show()www.baidu.com
       // m4 show->>m2: i will back
       // 异步引入依赖模块m3 hahahaha
   </script>
   </html>
   ```

### **4、ES6模块化**

- ES6概述

  ES6模块的设计思想是尽量静态化，使得编译时，就能确定模块的依赖关系、输入和输出的变量。

  CommonJs和AMD模块，只能在运行时确定依赖关系、输入和输出的变量。

- ES6模块化基本语法

  1）export模块：

  ```js
  // 定义没有依赖的模块
  var myName = 'cavin'
  var nbaStart = 'LBJ'
  function run(){ return 'go'}
  export {
  	myName,
      nbaStart,
      run
  }
  
  // 引用
  import {myFullName, superStart, toRun} from 'example.js'
  ```

  2）**export default命令**

  ```js
  // 抛出模块example2.js
  export default function () {
      ....
  }
  // 引用模块
  import useExample from 'example2.js'
  ```

### **es6 模块export与export default的区别**

#### 1.export命令用于规定模块的对外接口

一个模块就是一个独立文件。该文件内部的变量、方法和类对象，外部无法获取。若想获取，必须使用`export`

```javascript
// example.js
export var myName = 'cavin'
export var nbaStart = 'LBJ'
export function run(){ return 'go'}
```

es6将example.js文件视为一个模块，`export`对外部输出了能访问的变量。

`export`的另外一种写法：

```javascript
// example.js
var myName = 'cavin'
var nbaStart = 'LBJ'
function run(){ return 'go'}
export {
	myName,
    nbaStart,
    run
}
```

通常情况下，`export`导出的变量也可以更名，使用`as`关键字重命名。

```javascript
// example.js
var myName = 'cavin'
var nbaStart = 'LBJ'
function run(){ return 'go'}
export {
	myName as myFullName,
    nbaStart as superStart,
    run as toRun
}
```

导入的时候，使用`import`加载这个模块。

```javascript
import {myFullName, superStart, toRun} from 'example.js'
```

#### 2.export default命令，为模块指定默认输出

使用`import`命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。

为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到`export default`命令，为模块指定默认输出。

```javascript
// example2.js
export default function () {
    ....
}
```



---



#### 3.export与export default的使用区别

1. 使用expoet，import命令接受一对大括号，里面需要指定导入模块的变量名，导入时也可以用关键字as更改变量名。

```javascript
import { myFullName as useName } from 'example.js'
```

2. 与export命令区别，导入export default的模块，不需要大括号，import命令可以指定任意名字。

```javascript
import useExample from 'example2.js'
```

---



#### 区别总结：

1. export命令对外接口是有名称且import导入接口的名字需要一致，还需要大括号，而export default导出的，不需要一致名字和大括号。
2. export default命令指定模块输出，因此一个模块只有一个输出，唯一对应，所以不需要大括号。



## es6模块与CommonJs模块的区别

- CommonJs模块输入的是一个值的拷贝（缓存），es6模块输出的是值引用。

- CommonJs模块是运行时加载，es6模块是编译时输出接口。

  第二个差异是因为CommonJs加载的是一个对象，即module.exports属性，该对象只有在脚本运行时才会生成。

  而es6模块不是对象，它的对外接口是一种静态的定义，在代码解析阶段才会生成。

  ```js
  // lib.js
  export let counter = 3;
  export function incCounter() {
    counter++;
  }
  // main.js
  import { counter, incCounter } from './lib';
  console.log(counter); // 3
  incCounter();
  console.log(counter); // 4
  ```

  es6模块运行机制与CommonJs模块不一样，es6模块是动态引用的，不会缓存值，模块里面的变量绑定其所在的模块。



## 三、模块化的总结

1. CommonJs模块，是同步加载的，使用服务端的Node.js开发，不适用于浏览器的文件加载，容易一起阻塞。
2. AMD规范能在浏览器中异步加载，可以并行加载多个模块。但是，AMD规范开发成本高，代码的结构复杂。
3. CMD和AMD相似，既可以同步也可以异步，用于浏览器编程，依赖就近，延迟执行，但是依赖SPM打包，模块的加载逻辑偏重。
4. es6模块，在语言标准层面上，实现了模块功能，语法简单，完全可以取代CommonJs和AMD规范，服务器浏览器通用。

